{
  "version": 3,
  "sources": ["../../reaplay/src/helper.ts", "../../reaplay/src/index.tsx"],
  "sourcesContent": ["/**\n * convert time seconds to minutes : seconds\n * @function\n * @param {number} time\n * @description return the converted time like this = 03:14\n */\n\nexport const ConvertTimeToText = (time:number) => {\n    if(!time) time = 0;\n    var minutes:string = \"0\" + Math.floor(time / 60);\n    var seconds:string = \"0\" +  Math.floor(time - (parseInt(minutes)) * 60);\n    var result:string = minutes.substr(-2) + \":\" + seconds.substr(-2);\n    return result\n}", "import { ReactNode, useEffect, useRef, useState } from 'react'\nimport { ConvertTimeToText } from './helper'\n\ninterface Props {\n  tracks: string[]\n  startIndex?: number\n  children?: ((props: PlayerType) => ReactNode) | ReactNode\n}\n// prop types should be like this interface\n\n/**\n * Reaplay\n * @param {string[]} tracks\n * @param {number} startIndex\n * @param {any} children\n * @property {object}  player\n * @property {function} player.Logger\n * @property {boolean}  player.isLoading\n * @property {boolean}  player.isHaveError\n * @property {number}  player.trackIndex\n * @property {number}  player.setTrackIndex\n * @property {number}  player.duration\n * @property {string}  player.durationText\n * @property {number}  player.trackProgress\n * @property {string}  player.trackProgressText\n * @property {string}  player.trackStyling\n * @property {function}  player.onScrub\n * @property {function}  player.onScrubEnd\n * @property {boolean}  player.isPlaying\n * @property {function}  player.setIsPlaying\n * @property {function}  player.play\n * @property {function}  player.pause\n * @property {function}  player.toNextTrack\n * @property {function}  player.toPrevTrack\n * @property {boolean}  player.isRepeat\n * @property {function}  player.repeat\n * @property {number}  player.volume\n * @property {function}  player.setVolume\n * @property {number}  player.speed\n * @property {function}  player.playSlow\n * @property {function}  player.playNormal\n * @property {function}  player.playFast\n * @property {boolean}  player.isStopPlayMoreSong\n * @property {function}  player.StopPlayMoreSong\n * @property {boolean}  player.isShuffle\n * @property {function}  player.playShuffle\n * @property {function}  player.playRandom\n * @property {boolean}  player.isMute\n * @property {function}  player.mute\n * @property {function}  player.unmute\n * @property {number | string}  player.buffered\n * @property {string}  player.bufferedText\n * @property {function}  player.forward\n * @property {function}  player.backward\n * @property {function}  player.forceUpdatePlayer\n */\nexport const Reaplay = ({ tracks, startIndex = 0, children }: Props) => {\n  if (startIndex < 0 || startIndex > tracks.length) {\n    startIndex = 0\n  }\n  // handle the undifind index\n  // -----------------------------------------------\n\n  /**\n   * here manage states\n   * use state because react need update with state if you change something\n   *\n   * @category states\n   */\n\n  // State\n  const [trackIndex, setTrackIndex] = useState<number>(startIndex)\n  // index of the tracks array on play\n\n  const [trackProgress, setTrackProgress] = useState<number>(0)\n  // played progress\n\n  const [volume, setVolume] = useState<number>(100)\n  // volume of the playing song\n\n  const [speed, setSpeed] = useState<number>(1)\n  // volume of the playing song\n\n  const [isPlaying, setIsPlaying] = useState<boolean>(false)\n  // play - puase\n\n  const [isRepeat, setIsRepeat] = useState<boolean>(false)\n  // repeat the playing song\n\n  const [isStopPlayMoreSong, StopPlayMoreSong] = useState<boolean>(false)\n  // if the song come on end, stop and dont play more\n\n  const [isShuffleList, setIsShuffleList] = useState<boolean>(false)\n  // shuffle list do anything ranodm, next - prev - on done\n\n  const [isMute, setIsMute] = useState<boolean>(false)\n  //  control the player mute, unmute\n\n  const [buffered, setBuffered] = useState<number>(0)\n  //  control the player mute, unmute\n\n\n  const [isLoading, setIsLoading] = useState<boolean>(true)\n  const [isHaveError, setIsHaveError] = useState<boolean>(false)\n  const [forcePlayerUpdate, setForcePlayerUpdate] = useState<number>(0)\n  // helper states\n\n  // =====================================================\n\n  // --------\n  // *\n  // *\n  // *\n  // ---------------------------\n  /**\n   * here manage audio\n   * here i use js Audio class and ref for manage audio props and functions\n   *\n   */\n  const audioRef = useRef(new Audio(tracks[trackIndex]))\n  audioRef.current.autoplay = false\n  audioRef.current.volume = volume / 100\n  audioRef.current.muted = isMute\n  audioRef.current.playbackRate = speed\n\n  audioRef.current.onloadeddata = () => setIsLoading(false)\n  audioRef.current.onerror = () => setIsHaveError(true)\n\n  const intervalRef: { current: NodeJS.Timeout | null } = useRef(null)\n  const isReady = useRef(false)\n  // ---------------------------\n  // *\n  // *\n  // *\n  // --------\n\n  // =============================\n  // Destructure for conciseness\n\n  // song duration\n  const { duration } = audioRef.current\n\n  const currentPercentage = duration\n    ? `${(trackProgress / duration) * 100}%`\n    : '0%'\n  const trackStyling = `\n      -webkit-gradient(linear, 0% 0%, 100% 0%, color-stop(${currentPercentage}, #fff), color-stop(${currentPercentage}, #777))\n    `\n  // ==============================\n\n  // ==== Timer\n  /**\n   * change scrub value\n   * @function\n   * @description start the timing of song and detect when the song to ended\n   */\n\n  const startTimer = () => {\n    // Clear any timers already running\n    clearInterval(intervalRef.current as NodeJS.Timeout)\n\n    intervalRef.current = setInterval(() => {\n      if (audioRef.current.ended) {\n        if (!isStopPlayMoreSong) {\n          if (isShuffleList) {\n            playRandom()\n          } else {\n            if (isRepeat) {\n              onScrub(0);\n              audioRef.current.play();\n            } else {\n              toNextTrack()\n            }\n          }\n        }\n      } else {\n        setTrackProgress(audioRef.current.currentTime)\n      }\n    }, 1000)\n  }\n\n  /**\n   * change scrub value\n   * @function\n   * @param {number} value - The value for set on scrub\n   * @description set the scrub value on changing time\n   *\n   * on scrub get the slider or range tag value and replace it with playing song progress\n   */\n\n  const onScrub = (value: number): void => {\n    // Clear any timers already running\n    clearInterval(intervalRef.current as NodeJS.Timeout)\n    audioRef.current.currentTime = value\n    setTrackProgress(audioRef.current.currentTime)\n  }\n\n  // -----------\n\n  /**\n   * play song\n   * @function\n   * @description play the current song\n   */\n\n  const play = (): void => {\n    setIsPlaying(true)\n  }\n\n  // -----------\n\n  /**\n   * pause song\n   * @function\n   * @description pause the current song\n   */\n\n  const pause = (): void => {\n    setIsPlaying(false)\n  }\n\n  // -----------\n\n  /**\n   * change scrub value\n   * @function\n   * @description set the scrub value on key or click\n   * @summary optional function\n   *\n   * this optional function\n   */\n\n  const onScrubEnd = (): void => {\n    // If not already playing, start\n    if (!isPlaying) {\n      setIsPlaying(true)\n    }\n    startTimer()\n  }\n\n  /**\n   * go to prev song\n   * @function\n   * @description go prev song at tracks list\n   *\n   * if shuffle play is on (true) the prev song do random\n   * if its first song, play at last song in tracks list\n   */\n\n  const toPrevTrack = (): void => {\n    if (isShuffleList) {\n      playRandom()\n    } else {\n      if (trackIndex - 1 < 0) {\n        setTrackIndex(tracks.length - 1)\n      } else {\n        setTrackIndex(trackIndex - 1)\n      }\n    }\n  }\n\n  /**\n   * go to next song\n   * @function\n   * @description go next song at tracks list\n   *\n   * if shuffle play is on (true) the next song do random\n   * if the last song, come at first song on tracks list\n   */\n\n  const toNextTrack = (): void => {\n    if (isShuffleList) {\n      playRandom()\n    } else {\n      if (trackIndex < tracks.length - 1) {\n        setTrackIndex(trackIndex + 1)\n      } else {\n        setTrackIndex(0)\n      }\n    }\n  }\n\n  /**\n   * forward\n   * @function\n   * @description forward to 5s later of playing song\n   */\n\n  const forward = (): void => {\n    audioRef.current.currentTime += 5\n  }\n\n  /**\n   * backward\n   * @function\n   * @description backward to 5s before of Track progress\n   */\n\n  const backward = (): void => {\n    audioRef.current.currentTime -= 5\n  }\n\n  /**\n   * playSlow\n   * @function\n   * @description set the player speed to (0.5)\n   */\n\n  const playSlow = (): void => {\n    setSpeed(0.5)\n  }\n\n  /**\n   * playNormal\n   * @function\n   * @description set the player speed to normal mode, (1)\n   */\n\n  const playNormal = (): void => {\n    setSpeed(1)\n  }\n\n  /**\n   * playFast\n   * @function\n   * @description set player speed to (2), it be play 2x faster than normal mode\n   */\n\n  const playFast = (): void => {\n    setSpeed(2)\n  }\n\n  /**\n   * repeat\n   * @function\n   * @description set player to repeat current song\n   */\n\n  const repeat = (SetOnRepeat: boolean): void => {\n    if (SetOnRepeat) {\n      setIsRepeat(true)\n    } else {\n      setIsRepeat(false)\n    }\n  }\n\n  /**\n   * mute\n   * @function\n   * @description mute the player\n   */\n\n  const mute = (): void => {\n    setIsMute(true)\n  }\n\n  /**\n   * unmute\n   * @function\n   * @description unmute the player\n   */\n\n  const unmute = (): void => {\n    setIsMute(false)\n  }\n\n  /**\n   * shuffle play\n   * @function\n   * @description play a random song in tracks list\n   *\n   * get a random index from tracks length and play it\n   */\n\n  const playShuffle = (shuffle: boolean): void => {\n    if (shuffle) {\n      setIsShuffleList(true)\n    } else {\n      setIsShuffleList(false)\n    }\n  }\n\n  const playRandom = (): void => {\n    let songsLength: number = tracks.length - 1\n    let random: number = Math.floor(Math.random() * songsLength)\n    setTrackIndex(random)\n  }\n\n  const forceUpdatePlayer = (): void => {\n    setForcePlayerUpdate((prev) => prev + 1)\n  }\n\n  const update = (): void => {\n    onScrubEnd();\n  }\n\n  /**\n   * manage isPlay state for play or pause the song\n   * start timer for detect when the song ended or more ..\n   */\n\n  useEffect(() => {\n    if (isPlaying) {\n      audioRef.current.play()\n      startTimer()\n    } else {\n      audioRef.current.pause()\n    }\n  }, [isPlaying])\n\n  /**\n   * manage isRepeat update state for repeat the song\n   */\n\n  useEffect(() => {\n    onScrubEnd();\n  }, [isRepeat])\n\n  /**\n   * manage the buffered value of playing song\n   */\n  useEffect(() => {\n    if (duration > 0) {\n      let i\n      for (i = 0; i < audioRef.current.buffered.length; i++) {\n        setBuffered(\n          (audioRef.current.buffered.end(\n            audioRef.current.buffered.length - 1 - i\n          ) /\n            duration) *\n            100\n        )\n      }\n    }\n  }, [trackProgress])\n\n  /**\n   * manage track index and repeat time\n   * if track index changed, here be call ... and it change the audio ref src\n   * if fource update be called, it do anything at first\n   */\n\n  useEffect(() => {\n    audioRef.current.pause()\n    setIsPlaying(false)\n    setIsLoading(true)\n    setBuffered(0)\n\n    audioRef.current = new Audio(tracks[trackIndex])\n    setTrackProgress(audioRef.current.currentTime)\n    audioRef.current.onloadeddata = () => setIsLoading(false)\n\n    if (isReady.current) {\n      audioRef.current.play()\n      setIsPlaying(true)\n      startTimer()\n    } else {\n      // Set the isReady ref as true for the next pass\n      isReady.current = true\n    }\n  }, [trackIndex, forcePlayerUpdate])\n\n  /**\n   * clean the memory and pause the song for manage memory leak and\n   */\n  useEffect(() => {\n    // Pause and clean up on unmount\n    return () => {\n      audioRef.current.pause()\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n    }\n  }, [])\n\n  /**\n   * Logger\n   * @function\n   * @description get player state\n   *\n   * if some time you need get player states seconds by seconds can use it.\n   */\n\n  const Logger = (): void => {\n    console.log({\n      trackIndex,\n      duration: ConvertTimeToText(duration),\n      trackProgress: ConvertTimeToText(trackProgress),\n      isPlaying,\n      isRepeat,\n      isShuffleList,\n      isStopPlayMoreSong,\n      volume,\n      isLoading,\n      isHaveError,\n      speed\n    })\n  }\n\n  // *****************\n  // *********\n  // **\n  // ==============  return data\n  const data: PlayerType = {\n    Logger, // log the states\n    isLoading, // loading state\n    isHaveError, // error state\n    trackIndex, // playing index at tracks list\n    setTrackIndex, // set playing index at tracks list\n    duration, // playing song duration\n    durationText: ConvertTimeToText(audioRef.current.duration), // playing song duration by minutes and : spliter\n    trackProgress, // how much song played\n    trackProgressText: ConvertTimeToText(trackProgress), // how much song played by minutes and : spliter\n    trackStyling, // random style generated\n    onScrub, // on scrub function for change track progress\n    onScrubEnd,\n    isPlaying, // playing state\n    setIsPlaying, // playing state setter\n    play, // play current song\n    pause, // pause current song\n    toNextTrack, // play next song function\n    toPrevTrack, // play prevent song function\n    isRepeat, // repeat state\n    repeat, // set repeat state\n    volume, // volume state\n    setVolume, // set volume state\n    isStopPlayMoreSong, // stop play more song at song ended\n    StopPlayMoreSong, // set stop play more song\n    playShuffle, // play a random song at list function\n    isShuffle: isShuffleList, // is on shuffle or not\n    playRandom, // play a random song\n    isMute, // the player is mute\n    mute, // set player to mute\n    unmute, // set player to unmute\n    buffered, // the buffered value of the song\n    bufferedText: `${buffered}%`,\n    backward, // forward to 5s\n    forward, // backward to 5s\n    speed, // the speed range, 0.5 or 1 or 2\n    playSlow, // play slow playbackRate of track\n    playNormal, // play normal playbackRate of track\n    playFast, // play fast playbackRate of track\n    forceUpdatePlayer, // force Re-Render Player\n    update // update the player\n  }\n\n  // @ts-ignore\n  return children({\n    ...data\n  })\n}\n\nexport interface PlayerType {\n  Logger: Function\n  isLoading: boolean\n  isHaveError: boolean\n  trackIndex: number\n  setTrackIndex: (index: number) => void\n  duration: number\n  durationText: string\n  trackProgress: number\n  trackProgressText: string\n  trackStyling: string\n  onScrub: Function\n  onScrubEnd: Function\n  isPlaying: boolean\n  setIsPlaying: (isPlaying: boolean) => void\n  play: Function\n  pause: Function\n  toNextTrack: Function\n  toPrevTrack: Function\n  isRepeat: boolean\n  repeat: (setOnrepeat: boolean) => void\n  volume: number\n  setVolume: (volume: number) => void\n  speed: number\n  playSlow: Function\n  playNormal: Function\n  playFast: Function\n  isStopPlayMoreSong: boolean\n  StopPlayMoreSong: Function\n  playShuffle: (isShuffle: boolean) => void\n  isShuffle: boolean\n  playRandom: Function\n  isMute: boolean\n  mute: Function\n  unmute: Function\n  buffered: number | string\n  bufferedText: string\n  forward: Function\n  backward: Function\n  forceUpdatePlayer: Function\n  update: Function\n}\n"],
  "mappings": "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",
  "names": ["ConvertTimeToText", "time", "minutes", "Math", "floor", "seconds", "parseInt", "result", "substr", "Reaplay", "tracks", "startIndex", "children", "length", "useState", "trackIndex", "setTrackIndex", "trackProgress", "setTrackProgress", "volume", "setVolume", "speed", "setSpeed", "isPlaying", "setIsPlaying", "isRepeat", "setIsRepeat", "isStopPlayMoreSong", "StopPlayMoreSong", "isShuffleList", "setIsShuffleList", "isMute", "setIsMute", "buffered", "setBuffered", "isLoading", "setIsLoading", "isHaveError", "setIsHaveError", "forcePlayerUpdate", "setForcePlayerUpdate", "audioRef", "useRef", "Audio", "current", "autoplay", "muted", "playbackRate", "onloadeddata", "onerror", "intervalRef", "isReady", "duration", "currentPercentage", "trackStyling", "startTimer", "clearInterval", "setInterval", "ended", "playRandom", "onScrub", "play", "toNextTrack", "currentTime", "value", "pause", "onScrubEnd", "toPrevTrack", "forward", "backward", "playSlow", "playNormal", "playFast", "repeat", "SetOnRepeat", "mute", "unmute", "playShuffle", "shuffle", "songsLength", "random", "forceUpdatePlayer", "prev", "update", "useEffect", "i", "end", "Logger", "console", "log", "data", "durationText", "trackProgressText", "isShuffle", "bufferedText"]
}
