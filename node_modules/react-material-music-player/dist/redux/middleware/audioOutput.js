"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _actionCreators = _interopRequireDefault(require("../actionCreators.js"));
var _types = require("../types");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const audio = new _types.AudioOutput();
const audioOutput = store => {
  audio.addEventListener("timeupdate", () => {
    //set current time
    store.dispatch(_actionCreators.default.setCurrentTime(Math.floor(audio.currentTime)));

    // set time left
    store.dispatch(_actionCreators.default.setTimeLeft(Math.floor(isNaN(audio.duration) ? 0 : audio.duration - audio.currentTime)));
  });

  // set error listener
  audio.addEventListener("error", () => {
    store.dispatch(_actionCreators.default.stop());
  });

  // set canplay listener
  audio.addEventListener("canplay", () => {
    let mediaState = store.getState().mediaState;
    if (mediaState === _types.MediaState.PLAYING) audio.play().catch(() => store.dispatch(_actionCreators.default.stop()));
  });

  // set "on playback ended" listener
  audio.addEventListener("ended", () => {
    let state = store.getState();
    let currentTrack = state.currentTrack;
    let isLastTrack = currentTrack === state.playlist.length - 1;
    switch (state.repeatMode) {
      case _types.RepeatMode.REPEAT_ALL:
        if (isLastTrack) store.dispatch(_actionCreators.default.changeTrack(0));else store.dispatch(_actionCreators.default.changeTrack(++currentTrack));
        break;
      case _types.RepeatMode.REPEAT_ONE:
        audio.play(); // play again
        break;
      case _types.RepeatMode.NORMAL:
      default:
        if (isLastTrack) store.dispatch(_actionCreators.default.stop());else store.dispatch(_actionCreators.default.changeTrack(++currentTrack));
    }
  });

  // set default volume level
  audio.volume = store.getState().volume / 100;
  return next => action => {
    let state = store.getState();
    switch (action.type) {
      case _types.ActionTypes.CHANGE_TRACK:
        let nexTrack = state.playlist[action.payload.index];
        audio.setSrc(nexTrack);
        if (state.mediaState === _types.MediaState.PLAYING) audio.play().catch(() => store.dispatch(_actionCreators.default.stop()));
        break;
      case _types.ActionTypes.PLAY:
        audio.setSrc(state.playlist[state.currentTrack]);
        audio.play().catch(() => store.dispatch(_actionCreators.default.stop()));
        break;
      case _types.ActionTypes.PAUSE:
        audio.pause();
        break;
      case _types.ActionTypes.STOP:
        audio.clear();
        break;
      case _types.ActionTypes.SEEK:
        if (!isNaN(audio.duration) && isFinite(audio.duration)) audio.currentTime = action.payload.progress / 100 * audio.duration;
        break;
      case _types.ActionTypes.CHANGE_VOLUME:
        audio.volume = action.payload.volume / 100;
        break;
      case _types.ActionTypes.SKIP_PREV:
        if (audio.currentTime > 3) {
          store.dispatch(_actionCreators.default.seek(0));
          return; // drop the action
        }

        break;
      default:
        break;
    }
    return next(action);
  };
};
var _default = exports.default = audioOutput;